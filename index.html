<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Seasoning Coverage — Triangle Mask</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body{margin:0;padding:16px;font-family:Arial;background:#fff;text-align:center}
h1{margin-bottom:12px}
#container{position:relative;width:92vw;max-width:420px;aspect-ratio:1/1;margin:auto;background:#000;border-radius:12px;overflow:hidden}
video,img{width:100%;height:100%;object-fit:cover;display:block}
canvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}
.controls{margin-top:12px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
button,label{background:#ff6a00;color:#fff;padding:10px 14px;border:none;border-radius:8px;cursor:pointer;font-weight:bold}
label{background:#444}
#coverage{margin-top:12px;font-weight:700}
.small{font-size:12px;color:#666;margin-top:6px}
</style>
</head>
<body>
<h1>Seasoning Coverage — Triangle Mask</h1>

<div id="container">
  <video id="video" autoplay playsinline muted></video>
  <img id="uploadedImg" style="display:none">
  <canvas id="overlayCanvas"></canvas>
</div>

<div class="controls">
  <button id="captureBtn">Capture & Analyze</button>
  <label>Upload Image<input type="file" id="fileInput" accept="image/*" style="display:none"></label>
</div>

<div id="coverage">Coverage: —</div>
<div class="small">If triangle not found, app falls back to default product area detection.</div>

<!-- hidden processing canvas -->
<canvas id="processCanvas" style="display:none"></canvas>

<!-- OpenCV.js (uses a known CDN build). It may take a second to load. -->
<script async src="https://cdn.jsdelivr.net/npm/@techstark/opencv-js@1.4.0/opencv.js"></script>

<script>
// DOM refs
const video = document.getElementById('video');
const uploadedImg = document.getElementById('uploadedImg');
const overlayCanvas = document.getElementById('overlayCanvas');
const processCanvas = document.getElementById('processCanvas');
const coverageEl = document.getElementById('coverage');
const captureBtn = document.getElementById('captureBtn');
const fileInput = document.getElementById('fileInput');

let cvReady = false;
let lastMask = null;

// Wait for OpenCV to be ready
function onOpenCvReady() {
  cvReady = true;
  console.log('OpenCV ready');
}
// technique: the opencv.js sets `cv` when loaded. Some builds provide onRuntimeInitialized.
if (typeof cv !== 'undefined') {
  if (cv.getBuildInformation) onOpenCvReady();
  else cv['onRuntimeInitialized']=onOpenCvReady;
}

// start camera
(async ()=>{
  try{
    const s = await navigator.mediaDevices.getUserMedia({ video:{facingMode:'environment'}, audio:false});
    video.srcObject = s;
  } catch(e){
    coverageEl.textContent = 'Allow camera permission in browser settings';
  }
})();


// ======= Seasoning / Unseasoned detectors (broader detection) =======
function isSeasonedRGB(r,g,b){
  // broader orange/red/yellow detection heuristic
  // returns true if pixel looks like seasoning (not pure white/beige)
  if (r > 120 && r > g + 15 && r > b + 15) return true;
  if ((r + g) > 210 && (r/g < 2.2) && (r/b > 1.1)) return true;
  // include some brownish (all channels moderate but r dominant)
  if (r > 100 && g > 60 && b > 40 && r > g*0.95 && r > b*1.05) return true;
  return false;
}
function isUnseasonedRGB(r,g,b){
  // white/beige detection: high brightness and low color variance
  const avg = (r+g+b)/3;
  const spread = Math.max(r,g,b) - Math.min(r,g,b);
  return (avg > 160 && spread < 30);
}


// ======= Triangle detection using OpenCV =======
function findTriangleMaskFromImage(imgElement){
  // Returns Uint8ClampedArray mask (1 inside triangle, 0 outside) sized procW*procH
  // If triangle not found returns null.
  if (!cvReady) return null;

  // draw image into processCanvas at original size
  const p = processCanvas;
  p.width = imgElement.videoWidth || imgElement.naturalWidth || imgElement.width;
  p.height = imgElement.videoHeight || imgElement.naturalHeight || imgElement.height;
  const pctx = p.getContext('2d');
  pctx.drawImage(imgElement, 0,0, p.width, p.height);

  // Create Mat from canvas
  let src = cv.imread(p);
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
  // blur then Canny
  let ksize = new cv.Size(5,5);
  cv.GaussianBlur(gray, gray, ksize, 0, 0, cv.BORDER_DEFAULT);
  let edges = new cv.Mat();
  cv.Canny(gray, edges, 60, 160);

  // find contours
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  // pick largest contour by area
  let maxArea = 0, maxIdx = -1;
  for (let i=0; i<contours.size(); i++){
    let cnt = contours.get(i);
    const area = cv.contourArea(cnt, false);
    if (area > maxArea){ maxArea = area; maxIdx = i; }
    cnt.delete();
  }
  if (maxIdx === -1 || maxArea < 500) {
    // cleanup
    src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    return null;
  }

  // Approximate polygon for largest contour
  let cnt = contours.get(maxIdx);
  let peri = cv.arcLength(cnt, true);
  let approx = new cv.Mat();
  cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

  // If approx has 3 vertices -> triangle. If more, try convex hull or polygon simplification to 3
  let poly = null;
  if (approx.rows === 3) {
    poly = approx;
  } else {
    // try to find triangle by finding largest triangular approximation among scaled epsilons
    for (let eps = 0.03; eps <= 0.12 && poly===null; eps += 0.01){
      cv.approxPolyDP(cnt, approx, eps * peri, true);
      if (approx.rows === 3) poly = approx;
    }
    // if still not triangle, compute convex hull and then approximate hull
    if (!poly){
      let hull = new cv.Mat();
      cv.convexHull(cnt, hull, false, true);
      for (let eps = 0.02; eps <= 0.12 && poly===null; eps += 0.01){
        cv.approxPolyDP(hull, approx, eps * peri, true);
        if (approx.rows === 3) poly = approx;
      }
      hull.delete();
    }
  }

  // Create mask if we have poly (triangle) OR if not, return null
  let mask = null;
  if (poly && poly.rows >= 3){
    // create blank mask Mat
    let maskMat = new cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
    // fill poly
    let pts = [];
    for (let i=0;i<poly.rows;i++){
      pts.push( new cv.Point(poly.intPtr(i,0)[0], poly.intPtr(i,0)[1]) );
    }
    let contoursFill = new cv.MatVector();
    let c = cv.matFromArray(pts.length, 1, cv.CV_32SC2, pts.flatMap(p=>[p.x,p.y]));
    contoursFill.push_back(c);
    cv.fillPoly(maskMat, contoursFill, new cv.Scalar(255,255,255,255));
    // convert mask to Uint8ClampedArray
    const maskData = new Uint8ClampedArray(maskMat.data);
    mask = {data: maskData, width: maskMat.cols, height: maskMat.rows};
    // cleanup
    c.delete(); contoursFill.delete(); maskMat.delete();
  }

  // cleanup mats
  src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
  cnt.delete(); approx.delete();

  return mask; // or null
}


// ======= Helper: restrict analysis to mask =======
function analyzeWithMask(sourceElement, maskObj){
  const p = processCanvas, pctx = p.getContext('2d');
  p.width = maskObj.width;
  p.height = maskObj.height;
  pctx.drawImage(sourceElement, 0,0, p.width, p.height);
  const img = pctx.getImageData(0,0,p.width,p.height);
  const d = img.data;
  let seasoned=0, total=0;

  // overlay canvas mapping
  const o = overlayCanvas;
  o.width = p.width; o.height = p.height;
  const octx = o.getContext('2d');
  octx.clearRect(0,0,o.width,o.height);

  for (let y=0; y<p.height; y++){
    for (let x=0; x<p.width; x++){
      const idx = (y*p.width + x)*4;
      if (maskObj.data[y*p.width + x] === 0) continue; // outside triangle
      const r = d[idx], g = d[idx+1], b = d[idx+2];
      // ignore very dark/bright background pixels even inside mask
      const sum = r+g+b;
      if (sum < 30 || sum > 750) continue;
      total++;
      if (isSeasonedRGB(r,g,b)) {
        seasoned++;
        octx.fillStyle = "rgba(255,0,0,0.55)"; // red
        octx.fillRect(x,y,1,1);
      } else if (isUnseasonedRGB(r,g,b)){
        octx.fillStyle = "rgba(0,120,255,0.55)"; // blue
        octx.fillRect(x,y,1,1);
      }
    }
  }
  const pct = total ? (seasoned/total)*100 : 0;
  coverageEl.textContent = `Coverage: ${pct.toFixed(1)}%`;
  lastMask = maskObj; // store last mask if needed
  return {pct,seasoned,total};
}

// ======= Fallback analysis (previous product-area method) =======
function fallbackAnalyze(sourceElement){
  // previous center-crop product detection (keeps largest component)
  const p = processCanvas, pctx = p.getContext('2d');
  p.width = sourceElement.videoWidth || sourceElement.naturalWidth || sourceElement.width;
  p.height = sourceElement.videoHeight || sourceElement.naturalHeight || sourceElement.height;
  pctx.drawImage(sourceElement, 0,0, p.width, p.height);
  const img = pctx.getImageData(0,0,p.width,p.height);
  const d = img.data;

  // simple luminance mask to find product area
  const W = p.width, H = p.height;
  const lum = new Float32Array(W*H);
  let sumLum = 0;
  for (let i=0,k=0;i<d.length;i+=4,k++){
    const r=d[i], g=d[i+1], b=d[i+2];
    const L = 0.2126*r + 0.7152*g + 0.0722*b;
    lum[k]=L; sumLum+=L;
  }
  const meanLum = sumLum / (W*H);
  const productMask = new Uint8ClampedArray(W*H);
  const thresh = meanLum * 0.98;
  for (let i=0;i<W*H;i++) productMask[i] = lum[i] < thresh ? 1 : 0;

  // keep largest connected region (simple two-pass flood-like)
  // We'll approximate: count contiguous components and keep biggest
  // (re-using earlier JS code would be possible; for speed we simply use all 'productMask' entries)

  // analyze within productMask 
  let seasoned=0, total=0;
  const o = overlayCanvas; o.width=W; o.height=H; const octx=o.getContext('2d'); octx.clearRect(0,0,W,H);
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const k = y*W + x;
      if (!productMask[k]) continue;
      const idx = k*4;
      const r=d[idx], g=d[idx+1], b=d[idx+2];
      const sum = r+g+b;
      if (sum < 30 || sum > 750) continue;
      total++;
      if (isSeasonedRGB(r,g,b)) { seasoned++; octx.fillStyle="rgba(255,0,0,0.55)"; octx.fillRect(x,y,1,1); }
      else if (isUnseasonedRGB(r,g,b)) { octx.fillStyle="rgba(0,120,255,0.55)"; octx.fillRect(x,y,1,1); }
    }
  }
  const pct = total ? (seasoned/total)*100 : 0;
  coverageEl.textContent = `Coverage: ${pct.toFixed(1)}% (fallback)`;
  return {pct,seasoned,total};
}

// ======= Flow: analyze uploaded image or live video, prefer triangle mask if available =======
async function analyzeSmart(sourceElement){
  // Wait for OpenCV ready for triangle detection (if available)
  let mask = null;
  if (cvReady){
    mask = findTriangleMaskFromImage(sourceElement);
  }
  if (mask){
    // call mask-based analysis
    return analyzeWithMask(sourceElement, mask);
  } else {
    // fallback if no mask
    return fallbackAnalyze(sourceElement);
  }
}

// ======= helpers: isSeasoned and isUnseasoned from earlier =======
function isSeasonedRGB(r,g,b){
  if (r > 120 && r > g + 15 && r > b + 15) return true;
  if ((r + g) > 210 && (r/g < 2.2) && (r/b > 1.1)) return true;
  if (r > 100 && g > 60 && b > 40 && r > g*0.95 && r > b*1.05) return true;
  return false;
}
function isUnseasonedRGB(r,g,b){
  const avg = (r+g+b)/3;
  const spread = Math.max(r,g,b) - Math.min(r,g,b);
  return (avg > 160 && spread < 30);
}

// ======= Button handlers =======
captureBtn.addEventListener('click', async ()=>{
  // analyze current live video frame
  const res = await analyzeSmart(video);
  console.log('analyzed live', res);
});

fileInput.addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  uploadedImg.src = url;
  uploadedImg.style.display = 'block';
  video.style.display = 'none';
  // ensure image loaded then analyze
  uploadedImg.onload = async ()=>{
    const res = await analyzeSmart(uploadedImg);
    console.log('analyzed upload', res);
  };
});

// expose coverageEl for earlier helper
const coverageEl = coverageEl || document.getElementById('coverage');

</script>
</body>
</html>


