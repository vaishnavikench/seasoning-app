<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Triangular Collet Seasoning Checker</title>
<style>
body { font-family: system-ui, -apple-system, Roboto, "Helvetica Neue", Arial; margin:0; padding:12px; background:#fafafa; color:#111; }
h1 { font-size:18px; margin:0 0 8px 0; text-align:center; }
.top { display:flex; gap:12px; flex-wrap:wrap; justify-content:center; }
video, .previewCanvas { width: 48vw; max-width:260px; border-radius:8px; background:#222; display:block; }
#results { margin-top:12px; font-weight:700; text-align:center; font-size:16px; }
button { padding:8px 12px; border-radius:6px; border:none; background:#0b63d6; color:white; font-weight:600; margin:4px; }
button:disabled { background:#9bbcf0; }
.footer { margin-top:14px; font-size:12px; color:#555; text-align:center; }
</style>
</head>
<body>
<h1>Triangular Collet Seasoning Checker</h1>

<div class="top">
  <div>
    <video id="video" autoplay playsinline></video><br>
    <button id="startCameraBtn">Start Camera</button>
    <button id="captureBtn" disabled>Capture & Analyze</button>
  </div>

  <div>
    <canvas id="canvas" class="previewCanvas"></canvas><br>
    <button id="uploadBtn">Upload Image</button>
    <input type="file" id="fileInput" accept="image/*" style="display:none;">
  </div>
</div>

<div id="results">Coverage: â€”</div>
<div class="footer">Detection runs fully on-device. Red = seasoned, Blue = unseasoned, Green outline = detected triangle.</div>

<script async src="https://docs.opencv.org/4.8.1/opencv.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {

  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const captureBtn = document.getElementById('captureBtn');
  const startCameraBtn = document.getElementById('startCameraBtn');
  const uploadBtn = document.getElementById('uploadBtn');
  const fileInput = document.getElementById('fileInput');
  const resultsText = document.getElementById('results');

  let stream = null;

  function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(s => {
        stream = s;
        video.srcObject = stream;
        video.play();
        captureBtn.disabled = false;
        startCameraBtn.disabled = true;
      })
      .catch(err => alert("Camera error: " + err));
  }

  startCameraBtn.addEventListener('click', startCamera);

  function analyzeImage(img) {
    const W = 320, H = 320;
    canvas.width = W; canvas.height = H;
    ctx.drawImage(img, 0, 0, W, H);
    let src = cv.imread(canvas);
    let dst = src.clone();

    // 1. Triangle detection
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let edges = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5),0);
    cv.Canny(blur, edges, 50,150);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let maxArea = 0;
    let triangleContour = null;
    for (let i=0; i<contours.size(); i++) {
      let cnt = contours.get(i);
      let approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, 0.02*cv.arcLength(cnt,true), true);
      if (approx.rows===3) {
        let area = cv.contourArea(approx);
        if (area > maxArea) {
          maxArea = area;
          triangleContour = approx;
        }
      }
      approx.delete();
    }

    if(!triangleContour) {
      resultsText.textContent = "Coverage: Triangle not detected!";
      src.delete(); dst.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
      return;
    }

    // 2. Mask triangle
    let mask = new cv.Mat.zeros(H,W,cv.CV_8UC1);
    cv.fillPoly(mask, new cv.MatVector([triangleContour]), new cv.Scalar(255));

    // 3. HSV seasoning detection
    let hsv = new cv.Mat();
    cv.cvtColor(src, hsv, cv.COLOR_RGBA2HSV);
    let seasonedMask = new cv.Mat.zeros(H,W,cv.CV_8UC1);

    for(let i=0;i<H;i++){
      for(let j=0;j<W;j++){
        if(mask.ucharPtr(i,j)[0]===0) continue;
        let px = hsv.ucharPtr(i,j);
        let h = px[0]*2;
        let s = px[1]/255;
        let v = px[2]/255;
        if(((h>=0 && h<=40)||(h>=340 && h<=360)) && s>=0.2 && v>=0.3) {
          seasonedMask.ucharPtr(i,j)[0] = 255;
        }
      }
    }

    // 4. Compute coverage %
    let total = cv.countNonZero(mask);
    let seasoned = cv.countNonZero(seasonedMask);
    let coverage = (seasoned/total*100).toFixed(2);
    resultsText.textContent = `Coverage: ${coverage}%`;

    // 5. Overlay: Red/Blue + Green triangle outline
    let overlay = ctx.getImageData(0,0,W,H);
    for(let i=0;i<H;i++){
      for(let j=0;j<W;j++){
        let idx = (i*W + j)*4;
        if(mask.ucharPtr(i,j)[0]===0) continue;
        if(seasonedMask.ucharPtr(i,j)[0]!==0){
          overlay.data[idx] = 255;   // R
          overlay.data[idx+1] = 0;   // G
          overlay.data[idx+2] = 0;   // B
          overlay.data[idx+3] = 180; // alpha
        } else {
          overlay.data[idx] = 0;
          overlay.data[idx+1] = 0;
          overlay.data[idx+2] = 255;
          overlay.data[idx+3] = 180;
        }
      }
    }
    ctx.putImageData(overlay,0,0);

    // Draw green outline
    ctx.strokeStyle = 'lime';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let pts = [];
    for(let i=0;i<triangleContour.rows;i++){
      pts.push({x:triangleContour.intPtr(i,0)[0], y:triangleContour.intPtr(i,0)[1]});
    }
    ctx.moveTo(pts[0].x, pts[0].y);
    ctx.lineTo(pts[1].x, pts[1].y);
    ctx.lineTo(pts[2].x, pts[2].y);
    ctx.closePath();
    ctx.stroke();

    // Cleanup
    src.delete(); dst.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    mask.delete(); hsv.delete(); seasonedMask.delete(); triangleContour.delete();
  }

  captureBtn.addEventListener('click', () => analyzeImage(video));
  uploadBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', (e) => {
    if(e.target.files.length===0) return;
    const img = new Image();
    img.onload = () => analyzeImage(img);
    img.src = URL.createObjectURL(e.target.files[0]);
  });

});
</script>
</body>
</html>
